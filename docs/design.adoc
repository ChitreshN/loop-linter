= Loop Linter: Technical Design Document
:toc: left
:toclevels: 3
:icons: font
:source-highlighter: highlightjs

== 1. Introduction

The **Loop Linter** is a static analysis tool implemented as a GHC Core-to-Core plugin. It identifies combinational loops in Clash hardware designs by analyzing the underlying GHC Core representation. This document details the architectural decisions, data structures, and algorithms used to achieve cross-module loop detection.

== 2. Architecture Overview

The linter is integrated into the GHC compilation pipeline. It executes after the **Desugarer** and initial **Simplifier** passes. This timing is critical: the code is simple enough to analyze (Core) but hasn't been so heavily optimized that all user intent is lost.

The system consists of four primary components:

1.  **Core Analyzer (`HasReg.hs`)**: Performs a recursive check on expressions to identify sequential logic.
2.  **Registry (`Registry.hs`)**: Manages disk-based persistence of `hasReg` metadata for cross-module visibility.
3.  **Graph Engine (`Graph.hs`, `MapBuilder.hs`)**: Constructs a directed dependency graph of signals.
4.  **Plugin Driver (`Plugin.hs`)**: Coordinates the passes and manages IO operations.

== 3. Core Analysis Logic

The fundamental question the linter asks is: *"Does this expression introduce a register boundary?"*

=== 3.1. Primitive Recognition
The analysis starts with a hardcoded list of Clash primitives in `RegPrimitives.hs`. We identify functions like `register`, `mealy`, `moore`, and `blockRam`. 

[IMPORTANT]
====
Currently, identification is based on `OccName` and `ModuleName`. A future improvement will use GHC `Unique`s or `Wire` annotations for higher precision.
====

=== 3.2. Recursive Expression Traversal
The function `exprHasReg :: CoreExpr -> Bool` performs a deep walk of the expression tree:

*   **Var**: If it's a primitive register, return `True`.
*   **App**: If either the function or the argument contains a register, return `True`.
*   **Let**: Analyzes both the bindings and the body.
*   **Case**: Analyzes the scrutinee and all branches.

This allows the linter to see through wrappers. If a user defines `myReg = register 0`, the linter identifies `myReg` as sequential.

== 4. Cross-Module Registry System

GHC analyzes one module at a time. To detect a loop between `Module A` and `Module B`, we must persist metadata.

=== 4.1. Persistence Mechanism
We use a file-based store in `.loop-linter-store/`.

*   **Format**: Each module generates a `.reginfo` file containing a serialized `Map String Bool`.
*   **Keys**: We use **Fully Qualified Names** (e.g., `Pentarisc.Prediction.BPU.mkBPU`). This is essential because simple names like `ds` or `mkBPU` are not unique across the whole project.
*   **Mapping**: `Registry.hs` provides `idToKey :: Id -> String` to bridge the gap between GHC's volatile `Id` types and persistent strings.

=== 4.2. Incremental Loading
When `analyzeModule` starts, it loads **all** existing `.reginfo` files. Since GHC compiles dependencies before dependents, the registry for an imported module is guaranteed to exist by the time the importing module is analyzed.

== 5. Graph Engine and Cycle Detection

The linter models the hardware as a netlist where wires are nodes and components are edges.

=== 5.2. The Callee Map (Dependency Graph)
`collectCallees` identifies every signal and function a binding depends on. 

*   **Dependencies**: When analyzing `x = f a b`, `collectCallees` now collects `{f, a, b}` as dependencies. This embeds the "producer" function directly into the dependency set for each node.
*   **Nested Apps**: Core represents `f a b` as `App (App f a) b`. The engine recursively descends these nodes to extract all arguments and the function head.

=== 5.3. Edge Breaking
Before cycle detection, we call `breakEdges`. This is the "magic" of the linter. For each node in the graph, it checks if **any** of its dependencies are sequential (i.e., known registers).

1.  Iterate through every node `k` and its dependency set `v` in the graph.
2.  If `any hasRegCheck v` is `True`, it means one of the inputs to `k` is a registered signal or primitive.
3.  The logic then **deletes all incoming edges** to node `k`, effectively making it a source node in the combinational graph.

This is a simpler model but has significant trade-offs (see Limitations section).

=== 5.4. Component-Based Cycle Detection (Tarjan's)
We employ **Tarjan's Strongly Connected Components (SCC)** algorithm, accessed via `Data.Graph.stronglyConnComp`.

*   **Logic**: Instead of attempting to trace every possible path through a loop (which can be exponentially expensive), we identify "knots" of mutually dependent signals.
*   **Why Tarjan's?**
    ** **Efficiency**: It runs in linear time `O(V + E)` , making it significantly faster than path-based searches on dense graphs.
    ** **Clarity**: When a loop exists, users typically need to know *which group* of signals is involved to insert a register. Reporting the component `{A, B, C}` is often more actionable than listing permutations `A->B->C->A`, `B->C->A->B`, etc.
*   **Alternatives Considered**:
    ** **Johnson's Algorithm**: While it finds *all* elementary cycles, it is computationally expensive (exponential worst-case) and produces excessive output for complex loops.
    ** **Iterative DFS**: Solves stack overflow issues but remains path-oriented, offering less structural insight than SCC.

== 6. Handling Desugared Artifacts

GHC desugars high-level Haskell into "Tuple Bundles". This is why you see many `ds` variables.

=== 6.1. The `ds` Problem
[source,haskell]
----
(a, b) = func x
----
becomes:
[source,haskell]
----
ds = func x
a = case ds of (p, q) -> p
b = case ds of (p, q) -> q
----
The loop detection identifies `ds` as a node. Since `ds` is produced by `func`, its dependency set includes `func`. If `func` is sequential, the edges to `ds` are broken.

=== 6.2. Name Recovery
Because GHC's Simplifier often inlines variables, the "user-friendly" name (like `readyDecode`) might be deleted, leaving only the `ds` bundle. The linter compensates by reporting the **Producer Function**, which is usually stable and recognizable to the engineer.

== 7. Limitations and Current Shortcomings

=== 1. No Alias Resolution (Major Issue)
The current `breakEdges` logic is simpler but **cannot resolve alias chains**.

Consider: `let z = register 0 i, y = z, x = y`.
Here, `x` is sequential. However, the linter will only break the graph at `z`. If there is a loop from `x` back to `i`, the path `x -> ... -> i -> z -> y -> x` will be incorrectly reported as a combinational loop. The previous `producerMap` logic handled this correctly, but has been removed. This is a significant regression that can lead to **false positives**.

=== 2. Loss of Source Names (Desugaring)
The most significant limitation is readability regarding variable names. GHC converts Haskell source code into **Core**, which is a much simpler language.

* **Tuple Unpacking**: Haskell code like `(a, b) = myFunc x` is desugared into temporary variables.
* **Inlining**: GHC aggressively inlines small definitions. If you define `let wire = ...`, GHC might replace all occurrences of `wire` with its definition, removing the named node from the graph entirely.

**Result:** The log file often reports cycles involving variables like `ds_...` or `<no location info>`. These are compiler-generated intermediate variables.

=== 3. Primitive Detection
The plugin relies on a list of known primitives (`LoopLinter/RegPrimitives.hs`) to identify the base cases of sequential logic.

* If a user defines a custom primitive in Verilog/VHDL and imports it via `BlackBox`, the plugin will not know it breaks a loop unless it is added to the primitive list.
* Workaround: Wrap the blackbox in a Haskell function; the plugin will analyze the wrapper, but since the wrapper just calls the blackbox (which looks like a function call), the plugin might assume it's combinational (default safety) unless told otherwise.

=== 4. Stale Registry Files
The `.loop-linter-store` directory accumulates `.reginfo` files.

* If you rename a module, the old `.reginfo` file remains.
* While not usually harmful (keys are fully qualified names), it can lead to clutter.
* **Recommendation:** Periodically clear the `.loop-linter-store` directory or add a clean step to your build process.

== 8. Summary of Analysis Workflow

1.  **Parse Core**: Extract all `Rec` and `NonRec` bindings.
2.  **Local Register Check**: Run `exprHasReg` on every binding.
3.  **Registry Sync**: Save local results; load results from other modules.
4.  **Build Graph**: Map signals to their dependencies.
5.  **Prune Graph**: Remove edges to nodes that have a registered dependency.
6.  **Find Cycles**: Run DFS on the pruned graph.
7.  **Log**: Write results to `loop-linter.log`.
