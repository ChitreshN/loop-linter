= Loop Linter Plugin for Clash
:toc: left
:icons: font
:source-highlighter: highlightjs

== Overview

The **Loop Linter** is a specialized GHC Plugin designed for Clash hardware development. Its primary purpose is to detecting **combinational loops** (tight loops with no registers) in hardware designs at compile time. 

While tools like Verilator or backend synthesis tools can detect these loops, catching them during the Haskell compilation phase provides faster feedback and allows developers to fix architectural issues before generating HDL.

== How It Works

The plugin operates as a `CoreDoPluginPass` within the GHC compilation pipeline. It inspects the **GHC Core** (the intermediate representation of Haskell code) after the type-checking and desugaring phases.

The analysis pipeline consists of four main stages:

=== 1. Registry Loading (Cross-Module Analysis)
One of the biggest challenges in analyzing combinational loops is that signals often cross module boundaries. GHC compiles modules one by one.

To solve this, the plugin implements a **Registry System**:

* When a module is compiled, the plugin analyzes every top-level binding to determine if it is "sequential" (contains a register) or "combinational".
* This information (`Function Name -> hasReg`) is persisted to disk in a `.loop-linter-store/` directory.
* When compiling subsequent modules, the plugin loads these registry files. This allows it to know if an imported function like `MyLib.mkController` breaks a combinational path, without needing access to `MyLib`'s source code at that moment.

=== 2. Graph Construction
For every top-level binding in the module being compiled, the plugin constructs a directed graph of the signal flow:

* **Nodes**: Variables (`Id`s) and function calls.
* **Edges**: Dependencies. If `x = f y`, there is an edge `y -> x`.
* **Producers**: The plugin identifies the "producer" function for every signal (e.g., `let x = register 0 y` identifies `register` as the producer of `x`).

The graph building logic handles:

* **Function Applications**: `f a b` depends on `f`, `a`, and `b`.
* **Let/Case Expressions**: Dependencies are traced through local bindings and case alternatives.
* **Tuple Unpacking**: It handles the intermediate "desugared" variables generated by GHC when unpacking tuples (e.g., `(a, b) = f x`).

=== 3. Edge Breaking (Register Detection)
A loop is only fatal if it is **combinational**. If a loop passes through a register, it is a valid sequential circuit.

The plugin "breaks" edges in the graph based on the `hasReg` property:

1.  **Primitives**: It checks against a hardcoded list of Clash primitives (e.g., `Clash.Prelude.register`, `mealy`, `moore`, `blockRam`).
2.  **Local Analysis**: It checks if the producer function in the current module was determined to contain a register.
3.  **Registry Lookup**: It checks the loaded registry for imported functions.

If a signal is produced by a registered function, its dependencies are cleared, effectively removing the back-edge in the graph.

=== 4. Cycle Detection
Finally, the plugin runs a **Depth-First Search (DFS)** on the processed graph. If it detects a path that visits a node already in the current recursion stack, a combinational loop is reported.

== Usage

To enable the plugin in your Clash project, add the following to your `.cabal` file under `ghc-options`:

[source,cabal]
----
ghc-options: -fplugin=LoopLinter.Plugin
----

The detected loops are appended to a log file named `loop-linter.log` in the project root.

== Limitations and Current Shortcomings

=== 1. Loss of Source Names (Desugaring)
The most significant limitation is readability regarding variable names. GHC converts Haskell source code into **Core**, which is a much simpler language.

* **Tuple Unpacking**: Haskell code like `(a, b) = myFunc x` is desugared into:
+
[source,haskell]
----
ds_d123 = myFunc x      -- Compiler generated bundle
a       = case ds_d123 of (p,q) -> p
b       = case ds_d123 of (p,q) -> q
----
* **Inlining**: GHC aggressively inlines small definitions. If you define `let wire = ...`, GHC might replace all occurrences of `wire` with its definition, removing the named node from the graph entirely.

**Result:** The log file often reports cycles involving variables like `ds_d123` or `<no location info>`. These are compiler-generated intermediate variables. The plugin attempts to mitigate this by printing the **Producer** (e.g., `Produced by: myFunc`), which usually gives enough context to identify the component.

=== 2. Primitive Detection
The plugin relies on a list of known primitives (`LoopLinter/RegPrimitives.hs`) to identify the base cases of sequential logic.

* If a user defines a custom primitive in Verilog/VHDL and imports it via `BlackBox`, the plugin will not know it breaks a loop unless it is added to the primitive list.
* Workaround: Wrap the blackbox in a Haskell function; the plugin will analyze the wrapper, but since the wrapper just calls the blackbox (which looks like a function call), the plugin might assume it's combinational (default safety) unless told otherwise.

=== 3. Stale Registry Files
The `.loop-linter-store` directory accumulates `.reginfo` files.

* If you rename a module, the old `.reginfo` file remains.
* While not usually harmful (keys are fully qualified names), it can lead to clutter.
* **Recommendation:** Periodically clear the `.loop-linter-store` directory or add a clean step to your build process.

=== 4. False Positives/Negatives
* **False Positives**: If the plugin fails to identify a register (e.g., complex higher-order function usage wrapping a register), it might report a combinational loop where there is none.
* **False Negatives**: If the graph traversal misses a subtle dependency (e.g., via type-class dictionaries or complex `Cast` expressions), it might miss a real loop.

== Future Improvements

* **Better Name Resolution**: Attempt to trace `ds_` variables back to their source `Let` bindings to find user-defined names attached to the tuple consumers.
* **GHC Warning Integration**: Emit standard GHC warnings/errors instead of writing to a log file, allowing integration with IDEs and `-Werror`.
* **Annotation Support**: Allow users to annotate functions with `{-# ANN f "Sequential" #-}` to manually inform the linter that a blackbox breaks loops.
