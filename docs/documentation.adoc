= Loop Linter Plugin for Clash
:toc: left
:icons: font
:source-highlighter: highlightjs

== Overview

The **Loop Linter** is a specialized GHC Plugin designed for Clash hardware development. Its primary purpose is to detecting **combinational loops** (tight loops with no registers) in hardware designs at compile time. 

While tools like Verilator or backend synthesis tools can detect these loops, catching them during the Haskell compilation phase provides faster feedback and allows developers to fix architectural issues before generating HDL.

== How It Works

The plugin operates as a `CoreDoPluginPass` within the GHC compilation pipeline. It inspects the **GHC Core** (the intermediate representation of Haskell code) after the type-checking and desugaring phases.

The analysis pipeline consists of four main stages:

=== 1. Registry Loading (Cross-Module Analysis)
One of the biggest challenges in analyzing combinational loops is that signals often cross module boundaries. GHC compiles modules one by one.

To solve this, the plugin implements a **Registry System**:

* When a module is compiled, the plugin analyzes every top-level binding to determine if it is "sequential" (contains a register) or "combinational".
* This information (`Function Name -> hasReg`) is persisted to disk in a `.loop-linter-store/` directory.
* When compiling subsequent modules, the plugin loads these registry files. This allows it to know if an imported function like `MyLib.mkController` breaks a combinational path, without needing access to `MyLib`'s source code at that moment.

=== 2. Graph Construction
For every top-level binding in the module being compiled, the plugin constructs a directed graph of the signal flow:

* **Nodes**: Variables (`Id`s) and function calls.
* **Edges**: Dependencies. If `x = f y`, there is an edge `y -> x`.
The graph building logic handles:

* **Function Applications**: When analyzing `x = f a b`, `collectCallees` now collects `{f, a, b}` as dependencies. This embeds the "producer" function directly into the dependency set for each node.
* **Let/Case Expressions**: Dependencies are traced through local bindings and case alternatives.
* **Tuple Unpacking**: It handles the intermediate "desugared" variables generated by GHC when unpacking tuples (e.g., `(a, b) = f x`).

=== 3. Edge Breaking (Register Detection)
A loop is only fatal if it is **combinational**. If a loop passes through a register, it is a valid sequential circuit.

The plugin "breaks" edges in the graph based on the `hasReg` property. For each node in the graph, it checks if **any** of its dependencies are sequential (i.e., known registers).

1.  Iterate through every node `k` and its dependency set `v` in the graph.
2.  If `any hasRegCheck v` is `True`, it means one of the inputs to `k` is a registered signal or primitive.
3.  The logic then **deletes all incoming edges** to node `k`, effectively making it a source node in the combinational graph.

This is a simpler model but has significant trade-offs (see Limitations section).

=== 4. Cycle Detection
Finally, the plugin runs **Tarjan's Strongly Connected Components (SCC)** algorithm on the processed graph. This identifies "knots" of mutually dependent signals (cycles) efficiently. Unlike simple path finding, this reports the set of signals involved in the loop, which is often more useful for debugging.

== Usage

To enable the plugin in your Clash project, add the following to your `.cabal` file under `ghc-options`:

[source,cabal]
----
ghc-options: -fplugin=LoopLinter.Plugin
----

The detected loops are appended to a log file named `loop-linter.log` in the project root.

== Limitations and Current Shortcomings

=== 1. No Alias Resolution (Major Issue)
The current `breakEdges` logic is simpler but **cannot resolve alias chains**.

Consider: `let z = register 0 i, y = z, x = y`.
Here, `x` is sequential. However, the linter will only break the graph at `z`. If there is a loop from `x` back to `i`, the path `x -> ... -> i -> z -> y -> x` will be incorrectly reported as a combinational loop. This is a significant regression that can lead to **false positives**.

=== 2. Loss of Source Names (Desugaring)
The most significant limitation is readability regarding variable names. GHC converts Haskell source code into **Core**, which is a much simpler language.

* **Tuple Unpacking**: Haskell code like `(a, b) = myFunc x` is desugared into:
+
[source,haskell]
----
ds_d123 = myFunc x      -- Compiler generated bundle
a       = case ds_d123 of (p,q) -> p
b       = case ds_d123 of (p,q) -> q
----
* **Inlining**: GHC aggressively inlines small definitions. If you define `let wire = ...`, GHC might replace all occurrences of `wire` with its definition, removing the named node from the graph entirely.

**Result:** The log file often reports cycles involving variables like `ds_d123` or `<no location info>`. These are compiler-generated intermediate variables. The plugin attempts to mitigate this by printing the **Producer** (e.g., `Produced by: myFunc`), which usually gives enough context to identify the component.

=== 3. Primitive Detection
The plugin relies on a list of known primitives (`LoopLinter/RegPrimitives.hs`) to identify the base cases of sequential logic.

* If a user defines a custom primitive in Verilog/VHDL and imports it via `BlackBox`, the plugin will not know it breaks a loop unless it is added to the primitive list.
* Workaround: Wrap the blackbox in a Haskell function; the plugin will analyze the wrapper, but since the wrapper just calls the blackbox (which looks like a function call), the plugin might assume it's combinational (default safety) unless told otherwise.

=== 4. Stale Registry Files
The `.loop-linter-store` directory accumulates `.reginfo` files.

* If you rename a module, the old `.reginfo` file remains.
* While not usually harmful (keys are fully qualified names), it can lead to clutter.
* **Recommendation:** Periodically clear the `.loop-linter-store` directory or add a clean step to your build process.

== Future Improvements

* **Re-introduce Alias Resolution**: A hybrid approach is needed that correctly resolves alias chains without failing on higher-order functions.
* **GHC Warning Integration**: Emit standard GHC warnings/errors instead of writing to a log file, allowing integration with IDEs and `-Werror`.
* **Annotation Support**: Allow users to annotate functions with `{-# ANN f "Sequential" #-}` to manually inform the linter that a blackbox breaks loops.
